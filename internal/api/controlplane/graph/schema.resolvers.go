package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"runtime"
	"time"

	"github.com/tjfontaine/polyglot-llm-gateway/internal/core/domain"
	"github.com/tjfontaine/polyglot-llm-gateway/internal/core/ports"
	"github.com/tjfontaine/polyglot-llm-gateway/internal/storage"
)

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*Stats, error) {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	return &Stats{
		Uptime:       time.Since(r.StartTime).String(),
		GoVersion:    runtime.Version(),
		NumGoroutine: runtime.NumGoroutine(),
		Memory: &MemoryStats{
			Alloc:      int64(m.Alloc),
			TotalAlloc: int64(m.TotalAlloc),
			Sys:        int64(m.Sys),
			NumGc:      int(m.NumGC),
		},
	}, nil
}

// Overview is the resolver for the overview field.
func (r *queryResolver) Overview(ctx context.Context) (*Overview, error) {
	resp := &Overview{
		Mode:       "single-tenant",
		Apps:       []AppSummary{},
		Frontdoors: []FrontdoorSummary{},
		Providers:  []ProviderSummary{},
		Tenants:    []TenantSummary{},
		Storage:    &StorageSummary{},
		Routing:    &RoutingSummary{Rules: []RoutingRule{}},
	}

	if r.Config != nil {
		resp.Storage = &StorageSummary{
			Enabled: r.Store != nil && r.Config.Storage.Type != "" && r.Config.Storage.Type != "none",
			Type:    r.Config.Storage.Type,
			Path:    strPtr(r.Config.Storage.SQLite.Path),
		}

		for _, app := range r.Config.Apps {
			summary := AppSummary{
				Name:            app.Name,
				Frontdoor:       app.Frontdoor,
				Path:            app.Path,
				Provider:        strPtr(app.Provider),
				DefaultModel:    strPtr(app.DefaultModel),
				EnableResponses: app.EnableResponses,
			}

			if len(app.ModelRouting.PrefixProviders) > 0 || len(app.ModelRouting.Rewrites) > 0 {
				prefixMap := make(map[string]any)
				for k, v := range app.ModelRouting.PrefixProviders {
					prefixMap[k] = v
				}
				summary.ModelRouting = &ModelRoutingSummary{
					PrefixProviders: prefixMap,
				}
				for _, rewrite := range app.ModelRouting.Rewrites {
					matchValue := rewrite.ModelExact
					if matchValue == "" {
						matchValue = rewrite.Match
					}
					summary.ModelRouting.Rewrites = append(summary.ModelRouting.Rewrites, ModelRewriteSummary{
						ModelExact:  strPtr(matchValue),
						ModelPrefix: strPtr(rewrite.ModelPrefix),
						Provider:    rewrite.Provider,
						Model:       rewrite.Model,
					})
				}
			}
			resp.Apps = append(resp.Apps, summary)
		}

		if len(resp.Apps) == 0 && len(r.Config.Frontdoors) > 0 {
			for _, fd := range r.Config.Frontdoors {
				resp.Apps = append(resp.Apps, AppSummary{
					Name:         fd.Type,
					Frontdoor:    fd.Type,
					Path:         fd.Path,
					Provider:     strPtr(fd.Provider),
					DefaultModel: strPtr(fd.DefaultModel),
				})
			}
		}

		resp.Routing = &RoutingSummary{
			DefaultProvider: r.Config.Routing.DefaultProvider,
			Rules:           []RoutingRule{},
		}
		for _, rule := range r.Config.Routing.Rules {
			resp.Routing.Rules = append(resp.Routing.Rules, RoutingRule{
				ModelPrefix: strPtr(rule.ModelPrefix),
				ModelExact:  strPtr(rule.ModelExact),
				Provider:    rule.Provider,
			})
		}

		if len(r.Config.Tenants) > 0 {
			resp.Mode = "multi-tenant"
		}

		for _, fd := range r.Config.Frontdoors {
			resp.Frontdoors = append(resp.Frontdoors, FrontdoorSummary{
				Type:         fd.Type,
				Path:         fd.Path,
				Provider:     strPtr(fd.Provider),
				DefaultModel: strPtr(fd.DefaultModel),
			})
		}

		for _, p := range r.Config.Providers {
			resp.Providers = append(resp.Providers, ProviderSummary{
				Name:              p.Name,
				Type:              p.Type,
				BaseURL:           strPtr(p.BaseURL),
				SupportsResponses: p.SupportsResponses,
				EnablePassthrough: p.EnablePassthrough,
			})
		}
	}

	for _, t := range r.Tenants {
		resp.Tenants = append(resp.Tenants, TenantSummary{
			ID:             t.ID,
			Name:           t.Name,
			ProviderCount:  len(t.Providers),
			RoutingRules:   len(t.Routing.Rules),
			SupportsTenant: true,
		})
	}

	return resp, nil
}

// Interactions is the resolver for the interactions field.
func (r *queryResolver) Interactions(ctx context.Context, filter *InteractionFilter, limit *int, offset *int) (*InteractionConnection, error) {
	if r.Store == nil {
		return &InteractionConnection{Interactions: []InteractionSummary{}, Total: 0}, nil
	}

	iStore, ok := r.Store.(storage.InteractionStore)
	if !ok {
		return &InteractionConnection{Interactions: []InteractionSummary{}, Total: 0}, nil
	}

	limitVal := 50
	offsetVal := 0
	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}

	tenantID := tenantIDFromContext(ctx)

	opts := storage.InteractionListOptions{
		TenantID: tenantID,
		Limit:    limitVal,
		Offset:   offsetVal,
	}

	if filter != nil {
		if filter.Frontdoor != nil {
			opts.Frontdoor = domain.APIType(*filter.Frontdoor)
		}
		if filter.Provider != nil {
			opts.Provider = *filter.Provider
		}
		if filter.Status != nil {
			opts.Status = *filter.Status
		}
	}

	interactions, err := iStore.ListInteractions(ctx, opts)
	if err != nil {
		return nil, err
	}

	result := make([]InteractionSummary, 0, len(interactions))
	for _, i := range interactions {
		status := string(i.Status)
		model := i.ServedModel
		result = append(result, InteractionSummary{
			ID:        i.ID,
			Type:      "interaction",
			Status:    &status,
			Model:     &model,
			Metadata:  toMapAny(i.Metadata),
			CreatedAt: i.CreatedAt.Unix(),
			UpdatedAt: i.UpdatedAt.Unix(),
		})
	}

	return &InteractionConnection{
		Interactions: result,
		Total:        len(result),
	}, nil
}

// Interaction is the resolver for the interaction field.
func (r *queryResolver) Interaction(ctx context.Context, id string) (*Interaction, error) {
	if r.Store == nil {
		return nil, nil
	}

	iStore, ok := r.Store.(storage.InteractionStore)
	if !ok {
		return nil, nil
	}

	tenantID := tenantIDFromContext(ctx)
	interaction, err := iStore.GetInteraction(ctx, id)
	if err != nil {
		return nil, nil
	}

	if interaction.TenantID != "" && tenantID != "" && interaction.TenantID != tenantID {
		return nil, nil
	}

	result := &Interaction{
		ID:             interaction.ID,
		TenantID:       interaction.TenantID,
		Frontdoor:      string(interaction.Frontdoor),
		Provider:       interaction.Provider,
		AppName:        strPtr(interaction.AppName),
		RequestedModel: interaction.RequestedModel,
		ServedModel:    strPtr(interaction.ServedModel),
		ProviderModel:  strPtr(interaction.ProviderModel),
		Streaming:      interaction.Streaming,
		Status:         string(interaction.Status),
		Duration:       interaction.Duration.String(),
		DurationNs:     int64(interaction.Duration),
		Metadata:       toMapAny(interaction.Metadata),
		RequestHeaders: toMapAny(interaction.RequestHeaders),
		CreatedAt:      interaction.CreatedAt.Unix(),
		UpdatedAt:      interaction.UpdatedAt.Unix(),
	}

	if interaction.Request != nil {
		result.Request = &InteractionRequest{
			Raw:             jsonRawToMap(interaction.Request.Raw),
			Canonical:       jsonRawToMap(interaction.Request.CanonicalJSON),
			UnmappedFields:  interaction.Request.UnmappedFields,
			ProviderRequest: jsonRawToMap(interaction.Request.ProviderRequest),
		}
	}

	if interaction.Response != nil {
		result.Response = &InteractionResponse{
			Raw:            jsonRawToMap(interaction.Response.Raw),
			Canonical:      jsonRawToMap(interaction.Response.CanonicalJSON),
			UnmappedFields: interaction.Response.UnmappedFields,
			ClientResponse: jsonRawToMap(interaction.Response.ClientResponse),
			FinishReason:   strPtr(interaction.Response.FinishReason),
		}
		if interaction.Response.Usage != nil {
			result.Response.Usage = &Usage{
				InputTokens:  intPtr(interaction.Response.Usage.PromptTokens),
				OutputTokens: intPtr(interaction.Response.Usage.CompletionTokens),
				TotalTokens:  intPtr(interaction.Response.Usage.TotalTokens),
			}
		}
	}

	if interaction.Error != nil {
		result.Error = &InteractionError{
			Type:    interaction.Error.Type,
			Code:    strPtr(interaction.Error.Code),
			Message: interaction.Error.Message,
		}
	}

	// Convert transformation steps
	for _, step := range interaction.TransformationSteps {
		result.TransformationSteps = append(result.TransformationSteps, TransformationStep{
			Stage:       step.Stage,
			Description: step.Description,
			Before:      anyToMap(step.Details),
			After:       nil, // Details is already the full transformation info
		})
	}

	// Get shadow results if available
	if shadowStore, ok := r.Store.(storage.ShadowStore); ok {
		shadows, err := shadowStore.GetShadowResults(ctx, id)
		if err == nil && len(shadows) > 0 {
			for _, s := range shadows {
				result.Shadows = append(result.Shadows, domainShadowToGraphQL(s))
			}
		}
	}

	return result, nil
}

// InteractionEvents is the resolver for the interactionEvents field.
func (r *queryResolver) InteractionEvents(ctx context.Context, interactionID string, limit *int) (*InteractionEventsResponse, error) {
	if r.Store == nil {
		return &InteractionEventsResponse{InteractionID: interactionID, Events: []InteractionEvent{}}, nil
	}

	iStore, ok := r.Store.(storage.InteractionStore)
	if !ok {
		return &InteractionEventsResponse{InteractionID: interactionID, Events: []InteractionEvent{}}, nil
	}

	limitVal := 500
	if limit != nil {
		limitVal = *limit
	}

	events, err := iStore.ListInteractionEvents(ctx, interactionID, storage.InteractionListOptions{
		Limit:  limitVal,
		Offset: 0,
	})
	if err != nil {
		return nil, err
	}

	result := &InteractionEventsResponse{
		InteractionID: interactionID,
		Events:        make([]InteractionEvent, 0, len(events)),
	}

	for _, e := range events {
		result.Events = append(result.Events, InteractionEvent{
			ID:                 e.ID,
			InteractionID:      e.InteractionID,
			Stage:              e.Stage,
			Direction:          string(e.Direction),
			APIType:            strPtr(string(e.APIType)),
			Frontdoor:          strPtr(string(e.Frontdoor)),
			Provider:           strPtr(e.Provider),
			AppName:            strPtr(e.AppName),
			ModelRequested:     strPtr(e.ModelRequested),
			ModelServed:        strPtr(e.ModelServed),
			ProviderModel:      strPtr(e.ProviderModel),
			ThreadKey:          strPtr(e.ThreadKey),
			PreviousResponseID: strPtr(e.PreviousResponseID),
			Raw:                jsonRawToMap(e.Raw),
			Canonical:          jsonRawToMap(e.Canonical),
			Headers:            jsonRawToMap(e.Headers),
			Metadata:           jsonRawToMap(e.Metadata),
			CreatedAt:          e.CreatedAt.Format(time.RFC3339),
		})
	}

	return result, nil
}

// ShadowResults is the resolver for the shadowResults field.
func (r *queryResolver) ShadowResults(ctx context.Context, interactionID string) (*ShadowResultsResponse, error) {
	if r.Store == nil {
		return &ShadowResultsResponse{InteractionID: interactionID, Shadows: []ShadowResult{}}, nil
	}

	shadowStore, ok := r.Store.(ports.ShadowStore)
	if !ok {
		return &ShadowResultsResponse{InteractionID: interactionID, Shadows: []ShadowResult{}}, nil
	}

	shadows, err := shadowStore.GetShadowResults(ctx, interactionID)
	if err != nil {
		return nil, err
	}

	result := &ShadowResultsResponse{
		InteractionID: interactionID,
		Shadows:       make([]ShadowResult, 0, len(shadows)),
	}

	for _, s := range shadows {
		result.Shadows = append(result.Shadows, domainShadowToGraphQL(s))
	}

	return result, nil
}

// DivergentShadows is the resolver for the divergentShadows field.
func (r *queryResolver) DivergentShadows(ctx context.Context, limit *int, offset *int, provider *string) (*DivergentShadowsResponse, error) {
	if r.Store == nil {
		return &DivergentShadowsResponse{Interactions: []InteractionSummary{}, Total: 0, Limit: 100, Offset: 0}, nil
	}

	shadowStore, ok := r.Store.(ports.ShadowStore)
	if !ok {
		return &DivergentShadowsResponse{Interactions: []InteractionSummary{}, Total: 0, Limit: 100, Offset: 0}, nil
	}

	limitVal := 100
	offsetVal := 0
	providerName := ""

	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}
	if provider != nil {
		providerName = *provider
	}

	interactions, err := shadowStore.ListDivergentInteractions(ctx, &ports.DivergenceListOptions{
		Limit:        limitVal,
		Offset:       offsetVal,
		ProviderName: providerName,
	})
	if err != nil {
		return nil, err
	}

	count, err := shadowStore.GetDivergentShadowCount(ctx)
	if err != nil {
		count = len(interactions)
	}

	result := &DivergentShadowsResponse{
		Interactions: make([]InteractionSummary, 0, len(interactions)),
		Total:        count,
		Limit:        limitVal,
		Offset:       offsetVal,
	}

	for _, i := range interactions {
		status := string(i.Status)
		model := i.ServedModel
		result.Interactions = append(result.Interactions, InteractionSummary{
			ID:        i.ID,
			Type:      "interaction",
			Status:    &status,
			Model:     &model,
			Metadata:  toMapAny(i.Metadata),
			CreatedAt: i.CreatedAt.Unix(),
			UpdatedAt: i.UpdatedAt.Unix(),
		})
	}

	return result, nil
}

// Shadow is the resolver for the shadow field.
func (r *queryResolver) Shadow(ctx context.Context, id string) (*ShadowResult, error) {
	if r.Store == nil {
		return nil, nil
	}

	shadowStore, ok := r.Store.(ports.ShadowStore)
	if !ok {
		return nil, nil
	}

	shadow, err := shadowStore.GetShadowResult(ctx, id)
	if err != nil {
		return nil, nil
	}

	result := domainShadowToGraphQL(shadow)
	return &result, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
